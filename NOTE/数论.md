#唯一分解定理

$$
\begin{align}
n = \prod_{i=1}^{k} p_i^{\alpha_{i}} = p_1^{\alpha_{1}} p_{2}^{\alpha_{2}} \cdots p_{m}^{\alpha_{m}}
\end{align}
$$
 
#欧拉函数

## 定义
The number of positive integers in the interval [1,n] that are ​**​coprime​**​ with n is denoted by $\varphi(n)$, which is called ​**​Euler's totient function**
## 性质
1. If **p** is prime, then $\varphi(p) = p - 1$
2. If **p** is prime, then  $\varphi(p^k) = (p - 1)p^{k - 1}$
3. **Multiplicative property**:  if $gcd(m, n) = 1$, then $\varphi(mn) = \varphi(m)\varphi(n)$
## 推导
$$
\varphi(p^\alpha) = (p - 1)p^{\alpha-1} = p^\alpha \left(1 - \frac{1}{p}\right)
$$
$$
\varphi(n) = \prod_{i=1}^m \varphi\left(p_i^{\alpha_i}\right) = \prod_{i=1}^m p_i^{\alpha_i}\left(1 - \frac{1}{p_{i}}\right) = n \prod_{i=1}^m \left(1 - \frac{1}{p_i}\right)
$$

#莫比乌斯函数

## 定义
$$
\mu(n) =
\begin{cases}
1 & \text{if } n = 1 \\\\
(-1)^k & \text{if } n \text{ is the product of } k \text{ distinct prime numbers} \\\\
0 & \text{if } n \text{ has a squared prime factor (i.e.\, } p^2 \mid n \text{ for some prime } p)
\end{cases}
$$

## 参考代码
```
std::vector<int> minp, primes, phi, mu;

void sieve(int n) {
    minp.assign(n + 1, 0);
    phi.assign(n + 1, 0);
    mu.assign(n + 1, 0);
    primes.clear();
    phi[1] = 1;
    mu[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            phi[i] = i - 1;
            mu[i] = -1;
            primes.push_back(i);
        }
        
        for (auto p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                phi[i * p] = phi[i] * p;
                break;
            }
            phi[i * p] = phi[i] * (p - 1);
            mu[i * p] = -mu[i];
        }
    }
}

```

## 解释

If we continue testing larger primes **q** to sieve **i×q**.  **p**(i.e. **minp[i]**) remains the smallest prime factor of **i×q**, not **q**.  So, to guarantee each number is marked only once by its smallest prime factor.  When **i mod p = 0** (i.e. **p = minp[i]**), we need to break.

```
if (p == minp[i]) {
    phi[i * p] = phi[i] * p;
    break;
}
```

```
phi[i * p] = phi[i] * (p - 1);
mu[i * p] = -mu[i]; 
```
